<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratorio: ML con Python - Sesion 08</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Segoe UI', system-ui, sans-serif; }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-100 to-slate-200 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState } = React;

        function App() {
            const [currentStep, setCurrentStep] = useState(0);
            const [completedSteps, setCompletedSteps] = useState([]);

            const labSteps = [
                {
                    title: 'Preparar Datos de Clientes',
                    duration: '10 min',
                    icon: 'üìä',
                    content: `
                        <div class="space-y-4">
                            <div class="bg-rose-50 border-l-4 border-rose-500 p-4">
                                <h4 class="font-bold text-rose-800">Caso: BancoDigital Panama</h4>
                                <p class="text-gray-700">
                                    Predecir que clientes aceptaran una oferta de tarjeta de credito premium
                                    y segmentar la base para campanas personalizadas.
                                </p>
                            </div>

                            <h4 class="font-bold text-lg">Paso 1: Crear dataset en Google Colab</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre># Crear dataset de clientes bancarios
import pandas as pd
import numpy as np
np.random.seed(42)

n = 2000

df = pd.DataFrame({
    'cliente_id': range(1, n+1),
    'edad': np.random.randint(22, 65, n),
    'antiguedad_meses': np.random.randint(1, 120, n),
    'saldo_promedio': np.round(np.random.exponential(5000, n), 2),
    'num_productos': np.random.choice([1, 2, 3, 4], n, p=[0.4, 0.35, 0.2, 0.05]),
    'tiene_tarjeta': np.random.choice([0, 1], n, p=[0.3, 0.7]),
    'usa_banca_movil': np.random.choice([0, 1], n, p=[0.4, 0.6]),
    'num_transacciones_mes': np.random.poisson(15, n),
    'ingreso_estimado': np.round(np.random.lognormal(10, 0.5, n), 0),
    'llamadas_soporte': np.random.poisson(1, n),
    'genero': np.random.choice(['M', 'F'], n),
    'region': np.random.choice(['Panama', 'Colon', 'Chiriqui', 'Veraguas'], n)
})

# Crear variable target (acepto_premium)
# Mayor probabilidad si: alto saldo, usa banca movil, muchos productos
prob_acepto = (
    0.1 +
    0.2 * (df['saldo_promedio'] > 5000).astype(int) +
    0.15 * df['usa_banca_movil'] +
    0.1 * (df['num_productos'] >= 2).astype(int) +
    0.1 * (df['ingreso_estimado'] > 30000).astype(int) +
    np.random.normal(0, 0.1, n)
).clip(0, 1)

df['acepto_premium'] = (np.random.random(n) < prob_acepto).astype(int)

print(f"Dataset creado: {df.shape}")
print(f"\\nTasa de aceptacion: {df['acepto_premium'].mean()*100:.1f}%")
df.head()</pre>
                            </div>

                            <div class="bg-green-50 border border-green-200 p-4 rounded-lg mt-4">
                                <h4 class="font-bold text-green-800">Verificacion</h4>
                                <p class="text-sm text-gray-700">
                                    Deberias ver: Dataset de 2000 clientes con ~35-40% de tasa de aceptacion.
                                </p>
                            </div>
                        </div>
                    `
                },
                {
                    title: 'Preparar Features para Modelado',
                    duration: '15 min',
                    icon: 'üîß',
                    content: `
                        <div class="space-y-4">
                            <div class="bg-rose-50 border-l-4 border-rose-500 p-4">
                                <h4 class="font-bold text-rose-800">Objetivo</h4>
                                <p class="text-gray-700">Preparar los datos: encoding, escalado y split train/test.</p>
                            </div>

                            <h4 class="font-bold text-lg">Celda 1: Encoding y seleccion de features</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre>from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import train_test_split

# Copiar datos para no modificar original
df_model = df.copy()

# Encoding de categoricas
le_genero = LabelEncoder()
df_model['genero_encoded'] = le_genero.fit_transform(df_model['genero'])

# One-hot encoding para region
df_model = pd.get_dummies(df_model, columns=['region'], prefix='region')

# Seleccionar features
feature_cols = [
    'edad', 'antiguedad_meses', 'saldo_promedio', 'num_productos',
    'tiene_tarjeta', 'usa_banca_movil', 'num_transacciones_mes',
    'ingreso_estimado', 'llamadas_soporte', 'genero_encoded',
    'region_Panama', 'region_Colon', 'region_Chiriqui', 'region_Veraguas'
]

X = df_model[feature_cols]
y = df_model['acepto_premium']

print(f"Features: {X.shape[1]}")
print(f"Registros: {X.shape[0]}")
print(f"\\nBalance de clases:")
print(y.value_counts(normalize=True))</pre>
                            </div>

                            <h4 class="font-bold text-lg mt-4">Celda 2: Split y escalado</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre># Split train/test
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

print(f"Train: {X_train.shape[0]} registros")
print(f"Test: {X_test.shape[0]} registros")

# Escalar features numericas
scaler = StandardScaler()

# Solo escalar las numericas continuas
cols_to_scale = ['edad', 'antiguedad_meses', 'saldo_promedio',
                  'num_transacciones_mes', 'ingreso_estimado', 'llamadas_soporte']

X_train_scaled = X_train.copy()
X_test_scaled = X_test.copy()

X_train_scaled[cols_to_scale] = scaler.fit_transform(X_train[cols_to_scale])
X_test_scaled[cols_to_scale] = scaler.transform(X_test[cols_to_scale])

print("\\nDatos escalados y listos para modelar")</pre>
                            </div>
                        </div>
                    `
                },
                {
                    title: 'Entrenar Modelo de Clasificacion',
                    duration: '20 min',
                    icon: 'üå≥',
                    content: `
                        <div class="space-y-4">
                            <div class="bg-rose-50 border-l-4 border-rose-500 p-4">
                                <h4 class="font-bold text-rose-800">Objetivo</h4>
                                <p class="text-gray-700">Entrenar y comparar Decision Tree vs Random Forest.</p>
                            </div>

                            <h4 class="font-bold text-lg">Celda 1: Decision Tree</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre>from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import matplotlib.pyplot as plt

# Entrenar Decision Tree
dt = DecisionTreeClassifier(
    max_depth=5,
    min_samples_split=20,
    random_state=42
)
dt.fit(X_train_scaled, y_train)

# Predecir
y_pred_dt = dt.predict(X_test_scaled)

# Evaluar
print("="*50)
print("DECISION TREE")
print("="*50)
print(f"Accuracy: {accuracy_score(y_test, y_pred_dt):.4f}")
print("\\nMatriz de Confusion:")
print(confusion_matrix(y_test, y_pred_dt))
print("\\nReporte de Clasificacion:")
print(classification_report(y_test, y_pred_dt))</pre>
                            </div>

                            <h4 class="font-bold text-lg mt-4">Celda 2: Random Forest</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre>from sklearn.ensemble import RandomForestClassifier

# Entrenar Random Forest
rf = RandomForestClassifier(
    n_estimators=100,
    max_depth=10,
    min_samples_split=10,
    random_state=42,
    n_jobs=-1
)
rf.fit(X_train_scaled, y_train)

# Predecir
y_pred_rf = rf.predict(X_test_scaled)
y_proba_rf = rf.predict_proba(X_test_scaled)[:, 1]

# Evaluar
print("="*50)
print("RANDOM FOREST")
print("="*50)
print(f"Accuracy: {accuracy_score(y_test, y_pred_rf):.4f}")
print("\\nMatriz de Confusion:")
print(confusion_matrix(y_test, y_pred_rf))
print("\\nReporte de Clasificacion:")
print(classification_report(y_test, y_pred_rf))</pre>
                            </div>

                            <h4 class="font-bold text-lg mt-4">Celda 3: Importancia de Features</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre># Feature Importance
importances = pd.DataFrame({
    'feature': feature_cols,
    'importance': rf.feature_importances_
}).sort_values('importance', ascending=True)

plt.figure(figsize=(10, 6))
plt.barh(importances['feature'], importances['importance'])
plt.xlabel('Importancia')
plt.title('Importancia de Features - Random Forest')
plt.tight_layout()
plt.show()

print("\\nTop 5 Features mas importantes:")
print(importances.tail())</pre>
                            </div>
                        </div>
                    `
                },
                {
                    title: 'Segmentacion con K-Means',
                    duration: '20 min',
                    icon: 'üîµ',
                    content: `
                        <div class="space-y-4">
                            <div class="bg-rose-50 border-l-4 border-rose-500 p-4">
                                <h4 class="font-bold text-rose-800">Objetivo</h4>
                                <p class="text-gray-700">Segmentar clientes para campanas de marketing diferenciadas.</p>
                            </div>

                            <h4 class="font-bold text-lg">Celda 1: Seleccionar variables de segmentacion</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre>from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

# Variables para segmentacion (RFM-like)
segmentation_cols = ['antiguedad_meses', 'saldo_promedio', 'num_transacciones_mes', 'num_productos']

X_cluster = df[segmentation_cols].copy()

# Escalar
scaler_cluster = StandardScaler()
X_cluster_scaled = scaler_cluster.fit_transform(X_cluster)

print("Variables de segmentacion:")
print(X_cluster.describe())</pre>
                            </div>

                            <h4 class="font-bold text-lg mt-4">Celda 2: Metodo del Codo</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre># Encontrar K optimo
inertias = []
silhouettes = []
K_range = range(2, 11)

for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans.fit(X_cluster_scaled)
    inertias.append(kmeans.inertia_)
    silhouettes.append(silhouette_score(X_cluster_scaled, kmeans.labels_))

# Graficar
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

axes[0].plot(K_range, inertias, 'bo-', linewidth=2, markersize=8)
axes[0].set_xlabel('Numero de Clusters (K)')
axes[0].set_ylabel('Inercia')
axes[0].set_title('Metodo del Codo')
axes[0].grid(True, alpha=0.3)

axes[1].plot(K_range, silhouettes, 'ro-', linewidth=2, markersize=8)
axes[1].set_xlabel('Numero de Clusters (K)')
axes[1].set_ylabel('Silhouette Score')
axes[1].set_title('Silhouette por K')
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f"\\nMejor Silhouette: K={K_range[np.argmax(silhouettes)]} (score={max(silhouettes):.3f})")</pre>
                            </div>

                            <h4 class="font-bold text-lg mt-4">Celda 3: Entrenar K-Means final</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre># Entrenar con K optimo
K_OPTIMO = 4

kmeans_final = KMeans(n_clusters=K_OPTIMO, random_state=42, n_init=10)
df['segmento'] = kmeans_final.fit_predict(X_cluster_scaled)

# Perfil de segmentos
print("="*60)
print("PERFIL DE SEGMENTOS")
print("="*60)

perfil = df.groupby('segmento')[segmentation_cols + ['acepto_premium']].mean()
perfil['count'] = df.groupby('segmento').size()
perfil['pct'] = (perfil['count'] / len(df) * 100).round(1)

print(perfil.round(2))</pre>
                            </div>
                        </div>
                    `
                },
                {
                    title: 'Visualizar Segmentos',
                    duration: '15 min',
                    icon: 'üìà',
                    content: `
                        <div class="space-y-4">
                            <div class="bg-rose-50 border-l-4 border-rose-500 p-4">
                                <h4 class="font-bold text-rose-800">Objetivo</h4>
                                <p class="text-gray-700">Visualizar y nombrar los segmentos de clientes.</p>
                            </div>

                            <h4 class="font-bold text-lg">Celda 1: Visualizacion de segmentos</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre>import seaborn as sns

# Scatter plot de segmentos
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Saldo vs Transacciones
scatter = axes[0].scatter(
    df['saldo_promedio'],
    df['num_transacciones_mes'],
    c=df['segmento'],
    cmap='viridis',
    alpha=0.6
)
axes[0].set_xlabel('Saldo Promedio ($)')
axes[0].set_ylabel('Transacciones/Mes')
axes[0].set_title('Segmentos: Saldo vs Actividad')
plt.colorbar(scatter, ax=axes[0], label='Segmento')

# Antiguedad vs Productos
scatter2 = axes[1].scatter(
    df['antiguedad_meses'],
    df['num_productos'],
    c=df['segmento'],
    cmap='viridis',
    alpha=0.6
)
axes[1].set_xlabel('Antiguedad (meses)')
axes[1].set_ylabel('Numero de Productos')
axes[1].set_title('Segmentos: Lealtad vs Productos')
plt.colorbar(scatter2, ax=axes[1], label='Segmento')

plt.tight_layout()
plt.show()</pre>
                            </div>

                            <h4 class="font-bold text-lg mt-4">Celda 2: Nombrar segmentos</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre># Asignar nombres descriptivos basados en el perfil
perfil_ordenado = df.groupby('segmento').agg({
    'saldo_promedio': 'mean',
    'num_transacciones_mes': 'mean',
    'num_productos': 'mean',
    'antiguedad_meses': 'mean',
    'acepto_premium': 'mean'
}).round(2)

print("Analisis para nombrar segmentos:")
print(perfil_ordenado)

# Ejemplo de nombres (ajustar segun tus resultados)
nombres_segmentos = {
    0: 'Nuevos Basicos',      # Baja antiguedad, pocos productos
    1: 'Activos Medios',      # Transacciones medias, saldo medio
    2: 'Premium Potencial',   # Alto saldo, alta actividad
    3: 'Leales Dormidos'      # Alta antiguedad, baja actividad
}

df['nombre_segmento'] = df['segmento'].map(nombres_segmentos)

# Distribucion final
print("\\nDistribucion de Segmentos:")
print(df['nombre_segmento'].value_counts())</pre>
                            </div>

                            <h4 class="font-bold text-lg mt-4">Celda 3: Tasa de conversion por segmento</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre># Analisis de conversion por segmento
conversion = df.groupby('nombre_segmento').agg({
    'acepto_premium': ['sum', 'count', 'mean']
}).round(3)

conversion.columns = ['Aceptaron', 'Total', 'Tasa_Conversion']
conversion = conversion.sort_values('Tasa_Conversion', ascending=False)

print("="*50)
print("CONVERSION POR SEGMENTO")
print("="*50)
print(conversion)

# Grafico de barras
plt.figure(figsize=(10, 5))
plt.bar(conversion.index, conversion['Tasa_Conversion'] * 100)
plt.ylabel('Tasa de Conversion (%)')
plt.title('Tasa de Aceptacion de Tarjeta Premium por Segmento')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()</pre>
                            </div>
                        </div>
                    `
                },
                {
                    title: 'Generar Recomendaciones',
                    duration: '10 min',
                    icon: 'üí°',
                    content: `
                        <div class="space-y-4">
                            <div class="bg-rose-50 border-l-4 border-rose-500 p-4">
                                <h4 class="font-bold text-rose-800">Objetivo</h4>
                                <p class="text-gray-700">Consolidar hallazgos en recomendaciones accionables.</p>
                            </div>

                            <h4 class="font-bold text-lg">Celda 1: Resumen ejecutivo</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre># Generar resumen
rf_accuracy = accuracy_score(y_test, y_pred_rf)
silhouette_final = silhouette_score(X_cluster_scaled, df['segmento'])

print("="*60)
print("RESUMEN EJECUTIVO - ANALISIS DE CLIENTES BANCODIGITAL")
print("="*60)
print(f"""
1. MODELO DE PROPENSION (Random Forest)
   - Accuracy: {rf_accuracy*100:.1f}%
   - Top predictores: saldo_promedio, ingreso_estimado, usa_banca_movil
   - Uso: Priorizar clientes para oferta de tarjeta premium

2. SEGMENTACION DE CLIENTES (K-Means)
   - {K_OPTIMO} segmentos identificados
   - Silhouette Score: {silhouette_final:.3f}
   - Segmentos: {list(nombres_segmentos.values())}

3. INSIGHTS CLAVE
   - El segmento 'Premium Potencial' tiene la mayor tasa de conversion
   - Clientes con banca movil tienen 2x mas probabilidad de aceptar
   - Antiguedad no es tan relevante como saldo y actividad

4. RECOMENDACIONES
   a) Campana prioritaria: Enfocar en 'Premium Potencial'
   b) Activacion digital: Promover banca movil en 'Leales Dormidos'
   c) Cross-sell: Aumentar productos en 'Nuevos Basicos'
   d) Score de propension: Usar modelo RF para priorizar leads
""")</pre>
                            </div>

                            <h4 class="font-bold text-lg mt-4">Celda 2: Exportar resultados</h4>
                            <div class="bg-gray-800 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">
<pre># Agregar score de propension al dataset
df['score_premium'] = rf.predict_proba(X_test_scaled)[:, 1] if len(df) == len(X_test_scaled) else np.nan

# Para todo el dataset
X_all_scaled = X_train_scaled.append(X_test_scaled) if hasattr(X_train_scaled, 'append') else X_scaled
# df['score_premium'] = rf.predict_proba(X_scaled)[:, 1]

# Guardar dataset enriquecido
df_export = df[['cliente_id', 'segmento', 'nombre_segmento', 'acepto_premium']]
df_export.to_csv('clientes_segmentados.csv', index=False)

print("Archivo exportado: clientes_segmentados.csv")
print(df_export.head())</pre>
                            </div>

                            <div class="bg-green-50 border border-green-200 p-4 rounded-lg mt-4">
                                <h4 class="font-bold text-green-800">Entregable del Laboratorio</h4>
                                <ul class="text-sm text-gray-700 space-y-1 mt-2">
                                    <li>‚úì Notebook con modelo de clasificacion (Random Forest)</li>
                                    <li>‚úì Segmentacion K-Means con K justificado</li>
                                    <li>‚úì Visualizaciones de segmentos</li>
                                    <li>‚úì Perfil y nombre de cada segmento</li>
                                    <li>‚úì Recomendaciones de negocio</li>
                                </ul>
                            </div>
                        </div>
                    `
                }
            ];

            const markComplete = (stepIndex) => {
                if (!completedSteps.includes(stepIndex)) {
                    setCompletedSteps([...completedSteps, stepIndex]);
                }
                if (stepIndex < labSteps.length - 1) {
                    setCurrentStep(stepIndex + 1);
                }
            };

            const progress = (completedSteps.length / labSteps.length) * 100;

            return (
                <div className="max-w-5xl mx-auto p-6">
                    {/* Header */}
                    <div className="bg-gradient-to-r from-emerald-600 to-teal-600 text-white p-6 rounded-xl shadow-lg mb-6">
                        <div className="flex items-center gap-2 text-emerald-100 mb-2">
                            <a href="./" className="hover:text-white">‚Üê Volver al simulador</a>
                        </div>
                        <h1 className="text-3xl font-bold mb-2">Laboratorio: ML con Python</h1>
                        <p className="text-emerald-100">Clasificacion y Clustering - Caso BancoDigital Panama</p>

                        {/* Progress bar */}
                        <div className="mt-4">
                            <div className="flex justify-between text-sm mb-1">
                                <span>Progreso</span>
                                <span>{completedSteps.length} de {labSteps.length} pasos</span>
                            </div>
                            <div className="w-full bg-emerald-800 rounded-full h-2">
                                <div
                                    className="bg-white rounded-full h-2 transition-all duration-300"
                                    style={{ width: `${progress}%` }}
                                />
                            </div>
                        </div>
                    </div>

                    <div className="grid md:grid-cols-4 gap-6">
                        {/* Sidebar */}
                        <div className="md:col-span-1 space-y-2">
                            {labSteps.map((step, index) => (
                                <button
                                    key={index}
                                    onClick={() => setCurrentStep(index)}
                                    className={`w-full text-left p-3 rounded-lg transition-all ${
                                        currentStep === index
                                            ? 'bg-emerald-100 border-2 border-emerald-500'
                                            : completedSteps.includes(index)
                                            ? 'bg-green-50 border border-green-300'
                                            : 'bg-white border border-gray-200 hover:border-emerald-300'
                                    }`}
                                >
                                    <div className="flex items-center gap-2">
                                        {completedSteps.includes(index) ? (
                                            <span className="text-green-500">‚úì</span>
                                        ) : (
                                            <span>{step.icon}</span>
                                        )}
                                        <span className="text-sm font-medium">{step.title}</span>
                                    </div>
                                    <div className="text-xs text-gray-500 ml-6">{step.duration}</div>
                                </button>
                            ))}
                        </div>

                        {/* Main content */}
                        <div className="md:col-span-3">
                            <div className="bg-white rounded-xl shadow-lg p-6">
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-2xl font-bold text-gray-800 flex items-center gap-2">
                                        <span>{labSteps[currentStep].icon}</span>
                                        {labSteps[currentStep].title}
                                    </h2>
                                    <span className="text-sm text-gray-500">
                                        {labSteps[currentStep].duration}
                                    </span>
                                </div>

                                <div
                                    dangerouslySetInnerHTML={{ __html: labSteps[currentStep].content }}
                                />

                                <div className="flex justify-between mt-6 pt-4 border-t">
                                    <button
                                        onClick={() => setCurrentStep(Math.max(0, currentStep - 1))}
                                        disabled={currentStep === 0}
                                        className="px-4 py-2 text-gray-600 disabled:opacity-50"
                                    >
                                        ‚Üê Anterior
                                    </button>

                                    <button
                                        onClick={() => markComplete(currentStep)}
                                        className={`px-6 py-2 rounded-lg font-medium transition-colors ${
                                            completedSteps.includes(currentStep)
                                                ? 'bg-green-100 text-green-700'
                                                : 'bg-emerald-600 text-white hover:bg-emerald-700'
                                        }`}
                                    >
                                        {completedSteps.includes(currentStep)
                                            ? '‚úì Completado'
                                            : currentStep === labSteps.length - 1
                                            ? 'Finalizar'
                                            : 'Marcar como completado ‚Üí'
                                        }
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Footer */}
                    <div className="mt-8 text-center text-gray-500 text-sm">
                        <p>Laboratorio Sesion 08 - Taller de Tecnologia Aplicada</p>
                        <p>ADEN University - Cuatrimestre I 2026</p>
                    </div>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
